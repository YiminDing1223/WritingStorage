<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="D">

<title>倒计时为负的三百六十五个日月 – FlowerForest</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">FlowerForest</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">目录首页</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">关于本站</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">我的作品</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../posts/flower-forest.html">
 <span class="dropdown-text">🌸 鲜花盛时的森林</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../plus/index.html">
 <span class="dropdown-text">📚 倒计时为负的三百六十五个日月（总目录）</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">倒计时为负的三百六十五个日月</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>D </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>（七）</p>
<p>金昇玟想龙馥有的时候是真得很能睡，吃饱了饭的时候身子身子总比脑子先一步倒下去，东倒西歪的时候眼神散了聚点，迷迷糊糊得，说话从前言不搭后语，到前个字搭不上后个词。他总得在这时候找到一个可以倚靠的据点，卸了力，把整个人交出去。</p>
<p>柱子可以，栏杆凑合，沙发最好，队友雨露均沾。他会半眯起眼睛，还一副难受极了的样子说这不是办法，不能睡哇，一边靠在昇玟的后背上，埋进去了贴着转了转头，盹就打上了。</p>
<p>他们把亲吻发展成了习惯，可牵手却始终是个难以逾越的关口。昇玟不喜欢牵手，龙馥也不喜欢整只手被包住的拘束感。他更愿意去摆弄昇玟的十指，像在玩什么精密的机关，又或者煞有其事地掰开他的掌心，装模作样地说：“我来给你算算生命线。”但凡到了“牵手”这一环，两人总是默契地避开，宁愿用指尖相叠来代替。</p>
<p>金昇玟总是那么得不动声色，说龙馥你给我看看，都能算出些什么？龙馥煞有其事地指指点点说我看到你的生命线里有我。他把自己的手掌贴了上去，两只手心最深的纹路严丝合缝地合在了一起，仿佛真能对号入座。</p>
<p>看手相是他们从熊猫Stay那儿学来的。李龙馥龙馥被逗得上了瘾，一进休息室就挨个去抓人玩。他那时兴奋得像装了马达，连工作人员都笑，说Lix玩疯啦，太把这儿当自己家了。</p>
<p>金昇玟听了非要去插一句，他说你们是没跟他去澳洲，回家到底还是不一样的，这里就算有袋鼠他也会客客气气退避三舍，你把他丢回澳洲，晚上说不定就能看到人拉着袋鼠跳华尔兹了。</p>
<p>这些话终究没出口。因为他知道，澳洲对他们来说并不只是调笑的背景。对龙馥，那是血脉和童年的延伸；对昇玟，却是一个在言语和想象中才渐渐生出的桃花源。</p>
<p>龙馥讲起澳大利亚的时候，手舞足蹈，眼睛都亮起来。他会说小时候的趣事，会描摹记忆里夺目的自然风景：蓝得发亮的天空，奔腾的海浪，还有路边不请自来的小动物。说着说着，话总会落在“昇玟，我一定要带你去看看”，或者“你去了就知道了”，甚至“运气好的话，说不定还能碰见——”。那时的他，热情得像是要把整片大陆都揽到怀里，送给昇玟。</p>
<p>可是第一次的澳洲之旅却并不顺利。昇玟推着轮椅，仰头看那片辽阔的天，心里竟生出一种近乎愚蠢的清澈满足：光是因为龙馥的描述，原来看见这片天空就已经足够了。可这种满足感一旦涌上心头，又像被什么锐利的针轻轻一刺，留下一点酸意。</p>
<p>然而另一位当事人却并不开心。他直播的时候说着说着就哭了，私下里看到金昇玟腰伤发作的时候也哭了，好像所有因病痛带来的倒霉与委屈，都不自觉流向了他那里。昇玟无从安慰，只能伸出手，安抚性地拍拍他的背，再捏捏他的肩。</p>
<p>不过他这个机会并不多，因为龙馥自告奋勇地拿下了推轮椅的重大任务。昇玟本来以为这只是个顺手的举动，可没过多久，他就发现龙馥推着他走路的样子，竟比平常任何时候都要认真。那双手紧紧握着扶手，肩膀微微用力，脚步沉稳得像在替他抵御什么风雨。</p>
<p>昇玟忍不住想笑，开口逗他说你这样子，好像护送什么大人物。龙馥却没笑，低着头闷声说本来就是啊。也不晓得是因为没有听清昇玟口中的调侃还是不觉得这是一个好玩的玩笑话，他的声音轻，却掷地有声。</p>
<p>昇玟觉得胸口又被戳了一下，不知道是心酸，还是别的什么，他对龙馥说，Lix哇，笑一个呗，我都来了，不就是想看看你说的这个地方吗？</p>
<p>结果李龙馥哭得更凄凉了，他说谢谢你昇玟，谢谢你能来。他把脸颊贴着昇玟的掌心，蹭了蹭，把脸颊贴在昇玟掌心，蹭了蹭。那时他的头发还是短的，大大咧咧得不怎么护理，发根划过手腕时有些刺。昇玟想，那一刻他大概真想俯身去亲亲他的脸，或者埋在发旋里，吸一口他身上像晨露落在草坪上的芬芳。</p>
<p>他们俩很神奇，在享受当下的时候会说我以前在这里有过什么美好，却闭口不谈未来。但这一次，龙馥的过去承接着未来，说着“我以前在这里见过什么”，却绝口不谈未来。可那一次，龙馥的过去却意外地承接着未来。</p>
<p>他一边说起小时候的笨拙与荒唐，一边郑重其事地许愿说昇玟我们下次来一定要试试这个，等你好了我一定要带你在田野间光着脚丫子跑一次，我和你说，有洁癖不要怕，我有特殊的冲洗技巧，还有我一定要让你体验一把我童年时的飞来横祸，倒霉得要命，荒唐至极！</p>
<p>他俩的对话有一搭没一搭，昇玟笑着拆台说那不太可能，你倒霉大部分原因是因为你太笨了。可他还是顺势接住了这些邀请，随口答说好嘛好嘛，去去去，一起体验。</p>
<p>李龙馥不甘示弱，他几乎寸步不离金昇玟。他说你来我就一定要带你体验些什么，不能有太多的遗憾。</p>
<p>他说的是不能有太多的遗憾，就好像遗憾成了注定。金昇玟心口微微一紧，他总觉得自己像一张巨大的蛛网，总会敏锐捕捉到这个非母语者韩语里笨拙的褶皱。他不想让话停在这里，便笑着否认，说和你一起来就没遗憾啦，现在又一直在一起，感觉好幸运！</p>
<p>他们不是没有脑补过小昇玟和小龙馥的相遇，想象他们命运的交织。明明很不一样，却总又相似得惊人。昇玟很难对龙馥说清，他的存在究竟意味着什么，因为久长的陪伴早已被他们当作理所当然。</p>
<p>金昇玟想，大概就是从那次开始，自己才第一次对“和李龙馥一起畅想未来”萌生出一点念头。青春是该有些年轻人放纵的冒险，在他的回忆里，那时的澳大利亚之旅对他而言可能就是迈出的印象最深的一步。可他觉得，冒险不是这趟旅程，不全是启梦的开始，而是李龙馥这个人自身闯进他生活里的勇气和他选择接纳的妥协。</p>
<p>No他举双手投降说好吧龙馥，你看我们一起来可不是为了哄作为东道主的你对吧？那就为了我开心些吧。</p>
<p>那时候李龙馥似乎就爱上了贴着他的背蹭蹭，他说昇玟是个大好人。他很喜欢两手搭在昇玟的肩上，说他的肩膀好宽好让人羡慕。后来学会韩语里“好男人”的梗之后，又改口成了“昇玟，好男人。”他说自己是个擅长按摩的超强能力者，趁这机会上手多薅了几把。</p>
<p>金昇玟一边享受着他的服务一边说，这算什么超能力者，那你服务于人民不得忙坏了，我岂不是很难有随叫随到的服务？</p>
<p>他这话只是调侃着玩，哪想给李龙馥记进了脑子。他真的一本正经地承担起了这个义务。后来他成了整个团的按摩代理人，团里几乎每个人都荣幸得沾了光。</p>
<p>龙馥自告奋勇归自告奋勇，还能每次转头，留一句给昇玟说，我可是把最好的服务留给了你。昇玟大度地想，那好吧！其实你不用和我说的。</p>
<p>他心说为什么要和我解释呢？面上喜笑宴宴，顺水推舟说我当然知道咏卟噶对我是最好的了。</p>
<p>李龙馥没忍住还是拆穿了他，指着他的胸口说，对每一个朋友都这么有独占欲不行哦，你这里可不是这么说的。</p>
<p>他又不想全盘否定他，于是补充说自己其实挺喜欢这样的，不过他们他们确实不一样。昇玟想，龙馥就是喜欢看他交朋友的样子，喜欢看他被人簇拥着的样子。不是一开始就那样，而是慢慢熟起来后才露出的心思，颇有一种要昭告天下说我看朋友眼光不错吧的得意。</p>
<p>金昇玟知道自己没法像李龙馥那样，总是那么明快张扬，但他能理解他的想法，而龙馥也能理解他。可他们之间始终有一条看不见的线，像是怎么都要隔开一点，亲吻了，上床了，那根线也还死皮赖脸地缠着。</p>
<p>龙馥有个很可爱的坏毛病，他觉得记住梦境是件很了不起的事，如果梦到了成员他就一定要分享。心情好的时候，金昇玟很荣幸地能常常被归进“美梦”一栏。可惜他的叙事能力总是稀碎，讲起梦来像屋内的氛围灯——一开就亮，但散得七零八落。</p>
<p>他就是那样的澳洲小子，充满活力，像是有着用不完的劲儿。这劲儿是力气，是精气神，是生命力。他边亲着金昇玟的侧脸，边贴着他絮絮叨叨。他说金昇玟我真得梦到过你变成小狗了哎！而且我竟然能一眼就认出你！特别小的一只，但是他们告诉我是金毛，超级可爱的康阿吉呼呼呼～</p>
<p>金昇玟被缠得没了脾气，生无可恋地说你不累吗，要不下次你来上我吧，我受不了了，太闹腾了。</p>
<p>从一个宿舍开始，李龙馥就喜欢在并排躺下或共享一张床的时候，把腿架在昇玟的腿上，怀里非要抱着点什么，才能安心睡着。</p>
<p>他不假思索地说我不要，我觉得你不会让我上的。</p>
<p>金昇玟叹口气，还是一脸认命，他说你精力旺盛，你赢了，我可以在下面。</p>
<p>李龙馥居然还认真想了想，点头道这个姿势好像也很不错。</p>
<p>金昇玟被他逗得大笑，笑着笑着望着天花板就发不出声音来了。他能意识到自己的胸口在震，充斥着悲怆和迷茫，觉得头顶光秃秃的天花板上多了许多星星点点，搅着他的实现，仿佛在把他和现实深深地剥离了开来。</p>
<p>李龙馥趴在他的胸口，听着他的心跳忽然说，我们要是以后一起住宿舍的话，我第一件事就是装个大灯。</p>
<p>金昇玟没答应，也没说不，他只是沉默地盯了会儿天花板，然后淡淡地说我觉得公司不会报销。</p>
<p>李龙馥唔了声，说那也好，我那儿氛围灯多，以后可以多批发一些。</p>
<p>金昇玟登时背脊一凉，随口怼回说到时候你自己搬吧，我不会陪你的。</p>
<p>那也就是说如果有机会两人宿舍的话，你会选择我的吧？李龙馥馥却听出弦外之音。</p>
<p>金昇玟丢回来一个反问，说你呢？</p>
<p>李龙馥咯咯地笑了起来。他声音太低了，声音低得像是从胸腔深处震出的暗流。他说我一直都是这样的，一直都是金昇玟，从来都没变过。</p>
<p>昇玟听到这句话时愣了一瞬，下意识偏了偏头，想从黑暗里辨清对方的神色。可夜色太深，他什么都看不真切，只能听见那笑声在胸口回荡。</p>
<hr>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>